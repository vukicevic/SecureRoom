<html>
<head>
  <meta charset="utf-8"> 
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>SecureRoom - Key Generator</title>
  <style>
    body {
      margin: 0;
    }
    .terminal {
      overflow-y: scroll;
      height: 100%;
      width: 100%;
      background-color: black;
      color: #bcefe6;
      font-family: monospace;
      text-shadow: 0 0 3px #bcefe6;
    }
    dl {
      float: left;
      white-space: pre;
      margin: 0.5em;
    }
    dt {
      float: left;
      clear: left;
    }
    dt:after {
      content: "> ";
    }
    dd {
      float: left;
      margin: 0;
    }
    dd.stdout, dd.stderr {
      clear: left;
    }
    dd>span {
      box-shadow: 0 0 3px #bcefe6;
    }
    .highlight {
      background-color: #bcefe6;
      color: black;
    }
    .nofocus {
      background-color: transparent !important;
      color: #bcefe6 !important;
    }
  </style>
  <script src="resources/mpi.js"></script>
  <script src="resources/random.default.js"></script>
  <script src="resources/asymmetric.rsa.js"></script>
  <script src="resources/hash.sha1.js"></script>
  <script src="resources/utils.js"></script>
</head>
<body>
  <div id="term" class="terminal"></div>
  <script>
  var KeyGenApp = {
    keys: {s: null, e: null},
    name: null,
    size: null,
    type: null,

    init: function(stdout, prompt, caller) {
      stdout("Terminal active. Type 'keygen' to generate RSA keys.");

      return function process(stdin) {
        switch (stdin) {
        case "keygen":
          return KeyGenApp.entry(stdout, prompt, process);
        default:
          stdout("Unknown command");
          return process;
        }
      }
    },

    exit: function(stdout, prompt, caller) {
      prompt("");
      return caller;
    },

    entry: function(stdout, prompt, caller) {
      stdout(" ", "Welcome to the RSA keygen app");
      prompt("keygen");
      return KeyGenApp.enterType(stdout, prompt, caller);
    },

    enterType: function(stdout, prompt, caller) {
      function print() {
        stdout(" ", "Choose a key format:", " ");
        stdout("1) Raw");
        stdout("2) OpenPGP (RFC4880)");
        stdout("3) OpenSSH (RFC4716)");
        stdout("4) PKCS #1 (RFC3447)");
        stdout(" ", "*** NOTE: PRIVATE KEY DATA IS NOT ENCRYPTED ***", " ");
      }

      prompt("Choose Format ");
      print();

      return function process(stdin) {
        type = parseInt(stdin);
        switch (type) {
          case 1:
          case 4:
            return KeyGenApp.enterSize(stdout, prompt, caller);
          case 2:
          case 3:
            return KeyGenApp.enterName(stdout, prompt, caller);
          default:
            type = null;
            stdout(" ", "Invalid input. Please select one of the presented options", " ");
            print();
            return process;
        }
      }
    },

    enterName: function(stdout, prompt, caller) {
      function print() {
        stdout(" ", "Enter a name. E.g. Bob, Mike, Bob Smith <bob@smith.com>", " ");
      }

      prompt("Enter Name ");
      print();

      return function process(stdin) {
        if (stdin.length > 2 && stdin.length < 250) {
          KeyGenApp.name = stdin;
          return KeyGenApp.enterSize(stdout, prompt, caller);
        }

        stdout(" ", "Invalid input. Name must be between 3 and 250 characters long");
        print();
        return process;
      }
    },

    enterSize: function(stdout, prompt, caller) {
      function print() {
        stdout(" ", "Enter a key size in bits, 512 <= s <= 4096", " ", "*** NOTE: KEY SIZES >2048 CAN TAKE A LONG TIME TO GENERATE ***", " ");
      }

      prompt("Enter Size ");
      print();

      return function process(stdin) {
        if (stdin > 511 && stdin < 4097) {
          KeyGenApp.size = stdin;
          switch (type) {
            case 1:
              KeyGen(KeyGenApp.size, KeyGenApp.printRaw(stdout, prompt, caller))();
            break;
            case 2:
              var callback = KeyGenApp.printGpg(stdout, prompt, caller);
              KeyGen(KeyGenApp.size, callback)();
              KeyGen(KeyGenApp.size, callback)();
            break;
            case 3:
              KeyGen(KeyGenApp.size, KeyGenApp.printSsh(stdout, prompt, caller))();
            break;
            case 4:
              KeyGen(KeyGenApp.size, KeyGenApp.printPk1(stdout, prompt, caller))();
            break;
          }

          return KeyGenApp.exit(stdout, prompt, caller);
        }

        stdout(" ", "Invalid input. Size must be between 128 and 4096 bits long.");
        print();
        return process;
      }
    },

    printGpg: function(stdout, prompt, caller) {
      function print() {
       stdout(" ", "Your keys are being generated...", " ");
      }

      print();

      return function process(stdin) {
        var c = Math.floor(Date.now()/1000);

        if (KeyGenApp.keys.s) {
          KeyGenApp.keys.e = { name: KeyGenApp.name, type: C.TYPE_RSA_ENCRYPT, data: stdin, time: c, size: ArrayUtil.bitLength(stdin.n), iden: KeyUtil.generateFingerprint(C.TYPE_RSA_ENCRYPT, stdin, c) };
          KeyGenApp.keys.e.sign = Asymmetric.sign(KeyGenApp.keys.s, KeyUtil.generateSignatureHash(KeyGenApp.keys.s, KeyGenApp.keys.e), true);

          stdout(KeyUtil.exportKey(KeyGenApp.keys.s, KeyGenApp.keys.e, true), " ");
          stdout(KeyUtil.exportKey(KeyGenApp.keys.s, KeyGenApp.keys.e), " ");

          KeyGenApp.keys = {s: null, e: null};
          KeyGenApp.name = null;
          KeyGenApp.size = null;
        } else {
          KeyGenApp.keys.s = { name: KeyGenApp.name, type: C.TYPE_RSA_SIGN, data: stdin, time: c, size: ArrayUtil.bitLength(stdin.n), iden: KeyUtil.generateFingerprint(C.TYPE_RSA_SIGN, stdin, c) };
          KeyGenApp.keys.s.sign = Asymmetric.sign(KeyGenApp.keys.s, KeyUtil.generateSignatureHash(KeyGenApp.keys.s), true);
        }

        return;
      }
    },

    printRaw: function(stdout, prompt, caller) {
      function print() {
        stdout(" ", "Your keys are being generated...", " ");
      }

      print();

      return function process(stdin, time) {
        for (var m in stdin)
          stdout(m+((m.length==2)?" ":"  ")+ArrayUtil.toHex(stdin[m]));
        
        stdout(" ");
        stdout("Elapsed time: "+time+"ms", " ");

        return;
      }
    },

    printPk1: function(stdout, prompt, caller) {
      function print() {
        stdout(" ", "Your keys are being generated...", " ");
      }

      print();

      return function process(stdin, time) {
        stdout(KeyUtil.exportPK1({ data: stdin }, true), " ");
        stdout(KeyUtil.exportPK1({ data: stdin }), " ");
        stdout("Elapsed time: "+time+"ms", " ");

        return;
      }
    },

    printSsh: function(stdout, prompt, caller) {
      function print() {
        stdout(" ", "Your keys are being generated...", " ");
      }

      print();

      return function process(stdin, time) {
        stdout(KeyUtil.exportPK1({ data: stdin }, true), " ");
        stdout(KeyUtil.exportSSH({ data: stdin, name: KeyGenApp.name }), " ");
        stdout("Elapsed time: "+time+"ms", " ");

        return;
      }
    }
  }

  function Terminal(container, state) {
    var shell = container.appendChild(document.createElement("dl")),
        input = shell.appendChild(document.createElement("dt")),
        field = shell.appendChild(document.createElement("dd")),
        caret = field.appendChild(document.createElement("span")),
        label = input.appendChild(document.createElement('span')),
        alive = true;

    function toggleCaret(highlight) {
      if (highlight || !caret.classList.contains("highlight")) {
        caret.classList.add("highlight");
      } else {
        caret.classList.remove("highlight");
      }

      if (highlight) {
        window.clearInterval(caret.timer);
        caret.timer = window.setInterval(toggleCaret, 600);
      }
    }

    function insertText(data, type) {
      var f = shell.insertBefore(document.createElement("dd"), input);
      
      if (type) f.classList.add(type);
      return f.appendChild(document.createTextNode(data)).textContent;
    }

    function insertLine(prompt, data, type) {
      var f = shell.insertBefore(document.createElement("dt"), input),
          n = f.appendChild(document.createElement("span"));
      
      n.appendChild(document.createTextNode(prompt));
      return insertText(data, type);
    }

    function clearLine() {
      if (caret.previousSibling) caret.previousSibling.remove();
      if (caret.nextSibling) caret.nextSibling.remove();
      caret.textContent = " ";
    }

    function moveLeft(remove) {
      if (!caret.previousSibling || caret.previousSibling.textContent == "") return false;
      if (!remove) {
        if (!caret.nextSibling) caret.parentNode.appendChild(document.createTextNode(""));
        caret.nextSibling.textContent = caret.textContent + caret.nextSibling.textContent;
        caret.textContent = caret.previousSibling.textContent.substring(caret.previousSibling.textContent.length - 1);
      }
      caret.previousSibling.textContent = caret.previousSibling.textContent.substring(0, caret.previousSibling.textContent.length - 1);
      return true;
    }

    function moveRight(remove) {
      if (!caret.nextSibling || caret.nextSibling.textContent == "") return false;
      if (!remove) {
        if (!caret.previousSibling) caret.parentNode.insertBefore(document.createTextNode(""), caret);
        caret.previousSibling.textContent = caret.previousSibling.textContent + caret.textContent;
      }
      caret.textContent = caret.nextSibling.textContent.substring(0, 1);
      caret.nextSibling.textContent = caret.nextSibling.textContent.substring(1);
      return true;
    }

    function control(event) {
      if (!alive) return;
      toggleCaret(true);
      switch (event.which) {
        case 13:
          event.preventDefault();
          execute();
        break;
        case 8:
          moveLeft(true);
        break;
        case 46:
          moveRight(true);
        break;
        case 37:
          moveLeft();
        break;
        case 39:
          moveRight();
        break;
        case 38:
          event.preventDefault();
          if (caret.pointer > 0) { 
            clearLine();
            caret.parentNode.insertBefore(document.createTextNode(shell.querySelectorAll("dd.stdin")[--caret.pointer].textContent.trim()), caret);
          }
        break;
        case 40:
          event.preventDefault();
          var lines = shell.querySelectorAll("dd.stdin");
          if (caret.pointer < lines.length) {
            clearLine();
            if (++caret.pointer < lines.length)
              caret.parentNode.insertBefore(document.createTextNode(lines[caret.pointer].textContent.trim()), caret);
          }
        break;
        case 35:
          while(moveRight());
        break;
        case 36:
          while(moveLeft());
        break;
        case 67:
          if (event.ctrlKey) clearLine();
        break;
      }
    }

    function write(event) {
      if (!alive || event.which < 32 || event.ctrlKey) return;
      if (!caret.previousSibling) {
        caret.parentNode.insertBefore(document.createTextNode(String.fromCharCode(event.which)), caret);
      } else {
        caret.previousSibling.textContent = caret.previousSibling.textContent + String.fromCharCode(event.which);
      }
    }

    function execute() {
      while(moveRight());
      if (caret.parentNode.textContent == " ") return;

      state = state(insertLine(label.textContent, caret.previousSibling.textContent, "stdin").trim());

      clearLine();
      input.scrollIntoView();
    
      caret.pointer = shell.querySelectorAll("dd.stdin").length;
    }

    caret.timer = window.setInterval(toggleCaret, 600);
    caret.textContent = " ";
    caret.pointer = 0;

    label.classList.add("label");

    window.addEventListener("keydown", control, true);
    window.addEventListener("keypress", write, true);
    window.addEventListener("click", function(e) { 
      alive = container.contains(e.target);
      if (alive) {
        caret.classList.remove("nofocus"); 
      } else { 
        caret.classList.add("nofocus"); 
      }
    }, true);

    state = state(function(data) { var args = Array.prototype.slice.call(arguments); while (args.length) insertText(args.shift(), "stdout"); input.scrollIntoView(); }, 
                  function(data) { if (label.firstChild) label.removeChild(label.firstChild); label.appendChild(document.createTextNode(data)); });

    return {
      setLabel: function(prompt) {
        if (label.firstChild) label.removeChild(label.firstChild);
        label.appendChild(document.createTextNode(prompt));
      },
      print: function(data, prompt) {
        return (prompt) ? insertLine(prompt, data, "") : insertText(data, "stdout");
      }
    };
  }

  var T = Terminal(document.getElementById("term"), KeyGenApp.init);
  </script>
</body>
</html>