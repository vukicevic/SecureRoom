<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>SecureRoom - Key Generator</title>
  <style>
    body {
      margin: 0;
    }
    .terminal {
      overflow-y: scroll;
      height: 100%;
      width: 100%;
      background-color: black;
      color: #bcefe6;
      font-family: monospace;
      text-shadow: 0 0 3px #bcefe6;
    }
    dl {
      float: left;
      white-space: pre;
      margin: 0.5em;
    }
    dt {
      float: left;
      clear: left;
    }
    dt:after {
      content: "> ";
    }
    dd {
      float: left;
      margin: 0;
    }
    dd.stdout, dd.stderr {
      clear: left;
    }
    dd>span {
      box-shadow: 0 0 3px #bcefe6;
    }
    .highlight {
      background-color: #bcefe6;
      color: black;
    }
    .nofocus {
      background-color: transparent !important;
      color: #bcefe6 !important;
    }
  </style>
  <script src="resources/mpi.js"></script>
  <script src="resources/random.default.js"></script>
  <script src="resources/asymmetric.rsa.js"></script>
  <script src="resources/hash.sha1.js"></script>
  <script src="resources/utils.js"></script>
</head>
<body>
  <div id="term" class="terminal"></div>
  <script>
  var KeyUtil = {
      createTag: function(tag, length) {
          return (length > 65535) ? tag*4 + 130 : (length > 255) ? tag*4 + 129 : tag*4 + 128;
      },

      createLength: function(l) {
          return (l < 256) ? [l] : (l < 65536) ? ArrayUtil.fromHalf(l) : ArrayUtil.fromWord(l);
      },

      createBerLength: function(l) {
          if (l < 128) return [l];

          var ll = Math.floor(Math.log(l)/Math.log(256))+1,
                  pr = [128 + ll];

          while (ll--) pr.push( (l >> (ll*8)) & 255 );

          return pr;
      },

      createMpi: function(mpi) {
          return ArrayUtil.fromHalf(ArrayUtil.bitLength(mpi)).concat(mpi);
      },


      createKeyPacketBase: function(key) {
          return [4].concat(ArrayUtil.fromWord(key.time))
                  .concat([key.type])
                  .concat(this.createMpi(key.data.n))
                  .concat(this.createMpi(key.data.e));
      },

      createKeyPacket: function(tag, length, key) {
          return [this.createTag(tag, length)].concat(this.createLength(length))
                  .concat(this.createKeyPacketBase(key));
      },

      createSecretKeyPacket: function(key) {
          var len = 21 + key.data.n.length + key.data.e.length + key.data.d.length + key.data.p.length + key.data.q.length + key.data.u.length,
                  tag = (key.type === C.TYPE_MASTER) ? 5 : 7,
                  tmp = [0].concat(this.createMpi(key.data.d)),
                  sum;

          tmp = (App.calc.compare(key.data.p, key.data.q) === -1)
                  ? tmp.concat(this.createMpi(key.data.p)).concat(this.createMpi(key.data.q))
                  : tmp.concat(this.createMpi(key.data.q)).concat(this.createMpi(key.data.p));

          tmp = tmp.concat(this.createMpi(key.data.u));
          sum = tmp.reduce(function(a, b) { return a + b }) % 65536;
          tmp = tmp.concat(ArrayUtil.fromHalf(sum));

          return this.createKeyPacket(tag, len, key).concat(tmp);
      },

      createPublicKeyPacket: function(key) {
          var len = 10 + key.data.n.length + key.data.e.length,
                  tag = (key.type === C.TYPE_MASTER) ? 6 : 14;

          return this.createKeyPacket(tag, len, key);
      },

      createNamePacket: function(name) {
          var namePacket = ArrayUtil.fromString(name);
          return [this.createTag(13, namePacket.length)].concat(this.createLength(namePacket.length)).concat(namePacket);
      },

      createSignaturePacket: function(sKey, eKey) {
          var sigMeta, sigHash, sigPacket, sigSigned;

          if (eKey) {
              sigMeta   = this.encryptSignatureMeta(eKey);
              sigSigned = eKey.sign;
          } else {
              sigMeta   = this.signSignatureMeta(sKey);
              sigSigned = sKey.sign;
          }

          sigHash   = this.generateSignatureHash(sKey, eKey);
          sigPacket = sigMeta.concat([0,10,9,16])
                  .concat(ArrayUtil.fromHex(sKey.iden.substr(-16)))
                  .concat(sigHash.slice(0,2))
                  .concat(this.createMpi(sigSigned));

          return [this.createTag(2, sigPacket.length)].concat(this.createLength(sigPacket.length)).concat(sigPacket);
      },

      encryptSignatureMeta: function(eKey) {
          return [4,24,2,2,0,15,5,2].concat(ArrayUtil.fromWord(eKey.time+2))
                  .concat([2,27,4,5,9])
                  .concat(ArrayUtil.fromWord(86400));
      },

      signSignatureMeta: function(sKey) {
          return [4,19,3,2,0,26,5,2].concat(ArrayUtil.fromWord(sKey.time+2))
                  .concat([2,27,3,5,9])
                  .concat(ArrayUtil.fromWord(86400))
                  .concat([4,11,7,8,9,2,21,2,2,22,0]);
      },

      generateSignatureHash: function(sKey, eKey) {
          var sdat, edat, meta, suff;

          sdat = this.createKeyPacketBase(sKey);
          sdat = [153].concat(ArrayUtil.fromHalf(sdat.length)).concat(sdat);

          if (eKey) {
              edat = this.createKeyPacketBase(eKey);
              edat = [153].concat(ArrayUtil.fromHalf(edat.length)).concat(edat);

              meta = this.encryptSignatureMeta(eKey);
          } else {
              edat = [180].concat(ArrayUtil.fromWord(sKey.name.length))
                      .concat(ArrayUtil.fromString(sKey.name));

              meta = this.signSignatureMeta(sKey);
          }

          suff = [4,255].concat(ArrayUtil.fromWord(meta.length));

          return Hash.digest(
                  sdat.concat(edat).concat(meta).concat(suff)
          );
      },

      generateFingerprint: function(type, data, time) {
          data = this.createKeyPacketBase({"type": type, "data": data, "time": time});
          return ArrayUtil.toHex(Hash.digest([0x99].concat(ArrayUtil.fromHalf(data.length)).concat(data)));
      },

      exportKey: function(sKey, eKey, secret) {
          var headers       = {"Version": "SecureRoom 1.0"},
                  namePacket    = this.createNamePacket(sKey.name),
                  signSigPacket = this.createSignaturePacket(sKey),
                  encSigPacket  = this.createSignaturePacket(sKey, eKey),
                  type, encryptPacket, signPacket;

          if (secret) {
              type          = "PRIVATE KEY BLOCK";
              encryptPacket = this.createSecretKeyPacket(eKey);
              signPacket    = this.createSecretKeyPacket(sKey);
          } else {
              type          = "PUBLIC KEY BLOCK";
              encryptPacket = this.createPublicKeyPacket(eKey);
              signPacket    = this.createPublicKeyPacket(sKey);
          }

          return ArmorUtil.dress({"type": type, "headers": headers, "packets": signPacket.concat(namePacket).concat(signSigPacket).concat(encryptPacket).concat(encSigPacket)});
      },

      exportSSH: function(key) {
          var prefix = [0, 0, 0, 7, 115, 115, 104, 45, 114, 115, 97];

          prefix = prefix.concat(ArrayUtil.fromWord(key.data.e.length))
                  .concat(key.data.e)
                  .concat(ArrayUtil.fromWord(key.data.n.length))
                  .concat(key.data.n);

          return "ssh-rsa " + Base64Util.encode(prefix) + " " + key.name;
      },

      exportPK1: function(key, secret) {
          var pref = [48], type, data;

          if (secret) {
              type = " PRIVATE KEY-----\n";
              data = [2,1,0,2].concat(this.createBerLength(key.data.n.length)).concat(key.data.n)
                      .concat([2]).concat(this.createBerLength(key.data.e.length)).concat(key.data.e)
                      .concat([2]).concat(this.createBerLength(key.data.d.length)).concat(key.data.d)
                      .concat([2]).concat(this.createBerLength(key.data.p.length)).concat(key.data.p)
                      .concat([2]).concat(this.createBerLength(key.data.q.length)).concat(key.data.q)
                      .concat([2]).concat(this.createBerLength(key.data.dp.length)).concat(key.data.dp)
                      .concat([2]).concat(this.createBerLength(key.data.dq.length)).concat(key.data.dq)
                      .concat([2]).concat(this.createBerLength(key.data.u.length)).concat(key.data.u);

          } else {
              type = " PUBLIC KEY-----\n";
              data = [2].concat(this.createBerLength(key.data.n.length)).concat(key.data.n)
                      .concat([2]).concat(this.createBerLength(key.data.e.length)).concat(key.data.e);
          }

          return "-----BEGIN RSA" + type + Base64Util.encode(pref.concat(this.createBerLength(data.length)).concat(data), true) + "\n-----END RSA" + type;
      }
  };

  var KeyGenApp = {
    keys: {s: null, e: null},
    name: null,
    size: null,
    type: null,

    init: function(stdout, prompt, caller) {
      stdout("Terminal active. Type 'keygen' to generate RSA keys.");

      return function process(stdin) {
        switch (stdin) {
        case "keygen":
          return KeyGenApp.entry(stdout, prompt, process);
        default:
          stdout("Unknown command");
          return process;
        }
      }
    },

    exit: function(stdout, prompt, caller) {
      prompt("");
      return caller;
    },

    entry: function(stdout, prompt, caller) {
      stdout(" ", "Welcome to the RSA keygen app");
      prompt("keygen");
      return KeyGenApp.enterType(stdout, prompt, caller);
    },

    enterType: function(stdout, prompt, caller) {
      function print() {
        stdout(" ", "Choose a key format:", " ");
        stdout("1) Raw");
        stdout("2) OpenPGP (RFC4880)");
        stdout("3) OpenSSH (RFC4716)");
        stdout("4) PKCS #1 (RFC3447)");
        stdout(" ", "*** NOTE: PRIVATE KEY DATA IS NOT ENCRYPTED ***", " ");
      }

      prompt("Choose Format ");
      print();

      return function process(stdin) {
        type = parseInt(stdin);
        switch (type) {
          case 1:
          case 4:
            return KeyGenApp.enterSize(stdout, prompt, caller);
          case 2:
          case 3:
            return KeyGenApp.enterName(stdout, prompt, caller);
          default:
            type = null;
            stdout(" ", "Invalid input. Please select one of the presented options", " ");
            print();
            return process;
        }
      }
    },

    enterName: function(stdout, prompt, caller) {
      function print() {
        stdout(" ", "Enter a name. E.g. Bob, Mike, Bob Smith <bob@smith.com>", " ");
      }

      prompt("Enter Name ");
      print();

      return function process(stdin) {
        if (stdin.length > 2 && stdin.length < 250) {
          KeyGenApp.name = stdin;
          return KeyGenApp.enterSize(stdout, prompt, caller);
        }

        stdout(" ", "Invalid input. Name must be between 3 and 250 characters long");
        print();
        return process;
      }
    },

    enterSize: function(stdout, prompt, caller) {
      function print() {
        stdout(" ", "Enter a key size in bits, 512 <= s <= 4096", " ", "*** NOTE: KEY SIZES >2048 CAN TAKE A LONG TIME TO GENERATE ***", " ");
      }

      prompt("Enter Size ");
      print();

      return function process(stdin) {
        if (stdin > 511 && stdin < 4097) {
          KeyGenApp.size = stdin;
          switch (type) {
            case 1:
              KeyGen(KeyGenApp.size, KeyGenApp.printRaw(stdout, prompt, caller))();
            break;
            case 2:
              var callback = KeyGenApp.printGpg(stdout, prompt, caller);
              KeyGen(KeyGenApp.size, callback)();
              KeyGen(KeyGenApp.size, callback)();
            break;
            case 3:
              KeyGen(KeyGenApp.size, KeyGenApp.printSsh(stdout, prompt, caller))();
            break;
            case 4:
              KeyGen(KeyGenApp.size, KeyGenApp.printPk1(stdout, prompt, caller))();
            break;
          }

          return KeyGenApp.exit(stdout, prompt, caller);
        }

        stdout(" ", "Invalid input. Size must be between 128 and 4096 bits long.");
        print();
        return process;
      }
    },

    printGpg: function(stdout, prompt, caller) {
      function print() {
       stdout(" ", "Your keys are being generated...", " ");
      }

      print();

      return function process(stdin) {
        var c = Math.floor(Date.now()/1000);

        if (KeyGenApp.keys.s) {
          KeyGenApp.keys.e = { name: KeyGenApp.name, type: C.TYPE_EPHEMERAL, data: stdin, time: c, size: ArrayUtil.bitLength(stdin.n), iden: KeyUtil.generateFingerprint(C.TYPE_EPHEMERAL, stdin, c) };
          KeyGenApp.keys.e.sign = Asymmetric.sign(KeyGenApp.keys.s, KeyUtil.generateSignatureHash(KeyGenApp.keys.s, KeyGenApp.keys.e), true);

          stdout(KeyUtil.exportKey(KeyGenApp.keys.s, KeyGenApp.keys.e, true), " ");
          stdout(KeyUtil.exportKey(KeyGenApp.keys.s, KeyGenApp.keys.e), " ");

          KeyGenApp.keys = {s: null, e: null};
          KeyGenApp.name = null;
          KeyGenApp.size = null;
        } else {
          KeyGenApp.keys.s = { name: KeyGenApp.name, type: C.TYPE_MASTER, data: stdin, time: c, size: ArrayUtil.bitLength(stdin.n), iden: KeyUtil.generateFingerprint(C.TYPE_MASTER, stdin, c) };
          KeyGenApp.keys.s.sign = Asymmetric.sign(KeyGenApp.keys.s, KeyUtil.generateSignatureHash(KeyGenApp.keys.s), true);
        }

        return;
      }
    },

    printRaw: function(stdout, prompt, caller) {
      function print() {
        stdout(" ", "Your keys are being generated...", " ");
      }

      print();

      return function process(stdin, time) {
        for (var m in stdin)
          stdout(m+((m.length==2)?" ":"  ")+ArrayUtil.toHex(stdin[m]));

        stdout(" ");
        stdout("Elapsed time: "+time+"ms", " ");

        return;
      }
    },

    printPk1: function(stdout, prompt, caller) {
      function print() {
        stdout(" ", "Your keys are being generated...", " ");
      }

      print();

      return function process(stdin, time) {
        stdout(KeyUtil.exportPK1({ data: stdin }, true), " ");
        stdout(KeyUtil.exportPK1({ data: stdin }), " ");
        stdout("Elapsed time: "+time+"ms", " ");

        return;
      }
    },

    printSsh: function(stdout, prompt, caller) {
      function print() {
        stdout(" ", "Your keys are being generated...", " ");
      }

      print();

      return function process(stdin, time) {
        stdout(KeyUtil.exportPK1({ data: stdin }, true), " ");
        stdout(KeyUtil.exportSSH({ data: stdin, name: KeyGenApp.name }), " ");
        stdout("Elapsed time: "+time+"ms", " ");

        return;
      }
    }
  }

  function Terminal(container, state) {
    var shell = container.appendChild(document.createElement("dl")),
        input = shell.appendChild(document.createElement("dt")),
        field = shell.appendChild(document.createElement("dd")),
        caret = field.appendChild(document.createElement("span")),
        label = input.appendChild(document.createElement('span')),
        alive = true;

    function toggleCaret(highlight) {
      if (highlight || !caret.classList.contains("highlight")) {
        caret.classList.add("highlight");
      } else {
        caret.classList.remove("highlight");
      }

      if (highlight) {
        window.clearInterval(caret.timer);
        caret.timer = window.setInterval(toggleCaret, 600);
      }
    }

    function insertText(data, type) {
      var f = shell.insertBefore(document.createElement("dd"), input);

      if (type) f.classList.add(type);
      return f.appendChild(document.createTextNode(data)).textContent;
    }

    function insertLine(prompt, data, type) {
      var f = shell.insertBefore(document.createElement("dt"), input),
          n = f.appendChild(document.createElement("span"));

      n.appendChild(document.createTextNode(prompt));
      return insertText(data, type);
    }

    function clearLine() {
      if (caret.previousSibling) caret.previousSibling.remove();
      if (caret.nextSibling) caret.nextSibling.remove();
      caret.textContent = " ";
    }

    function moveLeft(remove) {
      if (!caret.previousSibling || caret.previousSibling.textContent == "") return false;
      if (!remove) {
        if (!caret.nextSibling) caret.parentNode.appendChild(document.createTextNode(""));
        caret.nextSibling.textContent = caret.textContent + caret.nextSibling.textContent;
        caret.textContent = caret.previousSibling.textContent.substring(caret.previousSibling.textContent.length - 1);
      }
      caret.previousSibling.textContent = caret.previousSibling.textContent.substring(0, caret.previousSibling.textContent.length - 1);
      return true;
    }

    function moveRight(remove) {
      if (!caret.nextSibling || caret.nextSibling.textContent == "") return false;
      if (!remove) {
        if (!caret.previousSibling) caret.parentNode.insertBefore(document.createTextNode(""), caret);
        caret.previousSibling.textContent = caret.previousSibling.textContent + caret.textContent;
      }
      caret.textContent = caret.nextSibling.textContent.substring(0, 1);
      caret.nextSibling.textContent = caret.nextSibling.textContent.substring(1);
      return true;
    }

    function control(event) {
      if (!alive) return;
      toggleCaret(true);
      switch (event.which) {
        case 13:
          event.preventDefault();
          execute();
        break;
        case 8:
          moveLeft(true);
        break;
        case 46:
          moveRight(true);
        break;
        case 37:
          moveLeft();
        break;
        case 39:
          moveRight();
        break;
        case 38:
          event.preventDefault();
          if (caret.pointer > 0) {
            clearLine();
            caret.parentNode.insertBefore(document.createTextNode(shell.querySelectorAll("dd.stdin")[--caret.pointer].textContent.trim()), caret);
          }
        break;
        case 40:
          event.preventDefault();
          var lines = shell.querySelectorAll("dd.stdin");
          if (caret.pointer < lines.length) {
            clearLine();
            if (++caret.pointer < lines.length)
              caret.parentNode.insertBefore(document.createTextNode(lines[caret.pointer].textContent.trim()), caret);
          }
        break;
        case 35:
          while(moveRight());
        break;
        case 36:
          while(moveLeft());
        break;
        case 67:
          if (event.ctrlKey) clearLine();
        break;
      }
    }

    function write(event) {
      if (!alive || event.which < 32 || event.ctrlKey) return;
      if (!caret.previousSibling) {
        caret.parentNode.insertBefore(document.createTextNode(String.fromCharCode(event.which)), caret);
      } else {
        caret.previousSibling.textContent = caret.previousSibling.textContent + String.fromCharCode(event.which);
      }
    }

    function execute() {
      while(moveRight());
      if (caret.parentNode.textContent == " ") return;

      state = state(insertLine(label.textContent, caret.previousSibling.textContent, "stdin").trim());

      clearLine();
      input.scrollIntoView();

      caret.pointer = shell.querySelectorAll("dd.stdin").length;
    }

    caret.timer = window.setInterval(toggleCaret, 600);
    caret.textContent = " ";
    caret.pointer = 0;

    label.classList.add("label");

    window.addEventListener("keydown", control, true);
    window.addEventListener("keypress", write, true);
    window.addEventListener("click", function(e) {
      alive = container.contains(e.target);
      if (alive) {
        caret.classList.remove("nofocus");
      } else {
        caret.classList.add("nofocus");
      }
    }, true);

    state = state(function(data) { var args = Array.prototype.slice.call(arguments); while (args.length) insertText(args.shift(), "stdout"); input.scrollIntoView(); },
                  function(data) { if (label.firstChild) label.removeChild(label.firstChild); label.appendChild(document.createTextNode(data)); });

    return {
      setLabel: function(prompt) {
        if (label.firstChild) label.removeChild(label.firstChild);
        label.appendChild(document.createTextNode(prompt));
      },
      print: function(data, prompt) {
        return (prompt) ? insertLine(prompt, data, "") : insertText(data, "stdout");
      }
    };
  }

  var T = Terminal(document.getElementById("term"), KeyGenApp.init);
  </script>
</body>
</html>